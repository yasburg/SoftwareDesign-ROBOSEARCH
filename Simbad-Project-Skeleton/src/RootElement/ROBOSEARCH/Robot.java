// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package RootElement.ROBOSEARCH;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.*;

import javax.vecmath.Point3d;
import javax.vecmath.Vector3d;

import simbad.sim.Agent;
import simbad.sim.CameraSensor;
import simbad.sim.RangeSensorBelt;
import simbad.sim.RobotFactory;

/************************************************************/
/**
 * 
 */
public class Robot extends Agent implements Observer {
	/**
	 * 
	 */
	private int robotID;
	/**
	 * 
	 */
	private static boolean running = true;
	/**
	 * 
	 */
	private RobotStatus currentStatus;
	/**
	 * 
	 */
	private Direction robotDirection;
	/**
	 * 
	 */
	private Coordinate currentCoordinates;
	/**
	 * 
	 */
	private RangeSensorBelt sonars;
	/**
	 * 
	 */
	private boolean operatorControls = false;
	/**
	 * 
	 */
	private int counter;
	/**
	 * 
	 */
	private Coordinate nextDestination;
	/**
	 * 
	 */
	private CameraSensor camera;
	/**
	 * 
	 */
	private AdapterInterface AdapterInterface;
	/**
	 * 
	 */
	private CentralStation centralstation;

	/**
	 * 
	 * @param status 
	 * @return 
	 */
	public void setStatus(RobotStatus status) {
		this.currentStatus = status;
	}

	/**
	 * 
	 * @return 
	 * @param robotID 
	 */
	public RobotStatus getStatus(int robotID) {
		return currentStatus;
	}

	/**
	 * 
	 * @return 
	 */
	public Coordinate getCoordinate() {
		return currentCoordinates;
	}
	
	/**
	 * 
	 * @param direction 
	 * @return 
	 */
	//This function returns the coordinate thats 1 meter away from robot in direction of parameter
	//Normally its was logical to turn robot and get first sonar values but:
	//in that case it would take longer time because of the turn rate and it would visually look bad and repetative.
	//Also, in that case the initial position would be lost and to fix that other values and 
	//functions were needed so this way is choosen.
	public Coordinate checkCoordinate(Direction direction) {
			if(direction == Direction.NORTH){//if direction is NORTH then in this if statement every possible combination is implemented in such way that robot can get sonar values without turning around and it will report them.
				if(this.robotDirection == Direction.NORTH){//robot is directed to NORTH
					if(this.sonars.getMeasurement(0) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()-1), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()-1), CoordinateStatus.EMPTY);
						return temp;
					}
				}
				else if(this.robotDirection == Direction.WEST){//robot is directed to WEST
					if(this.sonars.getMeasurement(3) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()-1), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()-1), CoordinateStatus.EMPTY);
						return temp;
					}
				}
				else if(this.robotDirection == Direction.SOUTH){//robot is directed to SOUTH
					if(this.sonars.getMeasurement(2) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()-1), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()-1), CoordinateStatus.EMPTY);
						return temp;
					}					
				}
				else if(this.robotDirection == Direction.EAST){//robot is directed to EAST
					if(this.sonars.getMeasurement(1) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()-1), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()-1), CoordinateStatus.EMPTY);
						return temp;
					}					
				}
			}
			else if(direction == Direction.WEST){//if direction is WEST then in this if statement every possible combination is implemented in such way that robot can get sonar values without turning around and it will report them.
				if(this.robotDirection == Direction.NORTH){//robot is directed to NORTH
					if(this.sonars.getMeasurement(1) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()-1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()-1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.EMPTY);
						return temp;
					}
				}
				else if(this.robotDirection == Direction.WEST){//robot is directed to WEST
					if(this.sonars.getMeasurement(0) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()-1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()-1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.EMPTY);
						return temp;
					}				
				}
				else if(this.robotDirection == Direction.SOUTH){//robot is directed to SOUTH
					if(this.sonars.getMeasurement(3) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()-1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()-1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.EMPTY);
						return temp;
					}					
				}
				else if(this.robotDirection == Direction.EAST){//robot is directed to EAST
					if(this.sonars.getMeasurement(2) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()-1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()-1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.EMPTY);
						return temp;
					}					
				}			
			}
			else if(direction == Direction.SOUTH){//if direction is SOUTH then in this if statement every possible combination is implemented in such way that robot can get sonar values without turning around and it will report them.
				if(this.robotDirection == Direction.NORTH){//robot is directed to NORTH
					if(this.sonars.getMeasurement(2) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()+1), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()+1), CoordinateStatus.EMPTY);
						return temp;
					}
				}
				else if(this.robotDirection == Direction.WEST){//robot is directed to WEST
					if(this.sonars.getMeasurement(1) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()+1), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()+1), CoordinateStatus.EMPTY);
						return temp;
					}				
				}
				else if(this.robotDirection == Direction.SOUTH){//robot is directed to SOUTH
					if(this.sonars.getMeasurement(0) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()+1), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()+1), CoordinateStatus.EMPTY);
						return temp;
					}					
				}
				else if(this.robotDirection == Direction.EAST){//robot is directed to EAST
					if(this.sonars.getMeasurement(3) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()+1), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()+1), CoordinateStatus.EMPTY);
						return temp;
					}					
				}			
			}
			else if(direction == Direction.EAST){//if direction is EAST then in this if statement every possible combination is implemented in such way that robot can get sonar values without turning around and it will report them.
				if(this.robotDirection == Direction.NORTH){//robot is directed to NORTH
					if(this.sonars.getMeasurement(3) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()+1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()+1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.EMPTY);
						return temp;
					}
				}
				else if(this.robotDirection == Direction.WEST){//robot is directed to WEST
					if(this.sonars.getMeasurement(2) < 0.71){//this means there isn't any obstacle in that coordinate so status is EMPTY!!
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()+1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.OBSTACLE);
						return temp;	
					}
					else{//in this case there is obstacle in that coordinate so the status is OBSTACLE
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()+1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.EMPTY);
						return temp;
					}				
				}
				else if(this.robotDirection == Direction.SOUTH){//robot is directed to SOUTH
					if(this.sonars.getMeasurement(1) < 0.71){
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()+1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.OBSTACLE);
						return temp;
						
					}
					else{
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()+1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.EMPTY);
						return temp;
					}					
				}
				else if(this.robotDirection == Direction.EAST){//robot is directed to EAST
					if(this.sonars.getMeasurement(0) < 0.71){
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()+1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.OBSTACLE);
						return temp;
					}
					else{	
						Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX()+1, this.currentCoordinates.getCoordinateY()), CoordinateStatus.EMPTY);
						return temp;
					}					
				}				
			}
			//this is never going to happen!! just for warnings
			Coordinate temp = new Coordinate(this.AdapterInterface.convertCoordinate(this.currentCoordinates.getCoordinateX(), this.currentCoordinates.getCoordinateY()), CoordinateStatus.VISITED);
			return temp;
	}

	/**
	 * 
	 * @param north 
	 * @param west 
	 * @param south 
	 * @param east 
	 * @return 
	 */
	//More detailed explaination is in centralstatin.java since this function only calls the reportToMap()
	//If the amount of sensors will change this function and the function inside centralstation.java must be 
	//changed in order to prevent errors and bugs.
	public void reportToCS(Coordinate north, Coordinate west, Coordinate south, Coordinate east) {
		this.centralstation.reportToMap(north, west, south ,east);
	}

	/**
	 * 
	 * @return 
	 * @param direction 
	 */
	//This function will be used when the go to destination command is send through central station.
	//It basicly sets robot's direction as requested.
	public void setDirection(Direction direction) {//every case is implemented for robot to turn demanded direction
		try{
			this.setTranslationalVelocity(0.0);
			while(this.robotDirection != direction){
				this.rotateRight();
			}
		}
		catch(Exception e){
			System.out.println("EXCEPTION in setDirection()");
		}
	}

	/**
	 * 
	 * @return 
	 */
	public Direction getDirection() {
		return robotDirection;
	}

	/**
	 * 
	 * @param direction 
	 * @param north
	 * @return 
	 * @throws InterruptedException 
	 */
	
	/**
	 * 
	 * @param north
	 * @param west
	 * @param south
	 * @param east 
	 * @return 
	 */
	//This function will determine which coordinate robot should visit next
	//by looking each coordinates status's and at the end returning the 
	//one that is decided so that robot can move to that location by looking its X and Z(Y) coordinate
	public Coordinate getDestination(Coordinate north, Coordinate west, Coordinate south, Coordinate east) {
		//Here there should be if and else statements to determine which coordinate to return..
		//probably something like this:
		
		//if there is any EMPTY coordinates just return that(if there are more than one pick random)
		//else select from VISITED coordinates(randomly)
		List<Coordinate> emptyCoordinateList = new ArrayList<Coordinate>();
		if(north.getStatus() == CoordinateStatus.EMPTY && this.centralstation.map.coordinateList[(int) Math.rint(north.getCoordinateX())][(int) Math.rint(north.getCoordinateY())] == CoordinateStatus.EMPTY){
            emptyCoordinateList.add(north);
        }
        if(west.getStatus() == CoordinateStatus.EMPTY && this.centralstation.map.coordinateList[(int) Math.rint(west.getCoordinateX())][(int) Math.rint(west.getCoordinateY())] == CoordinateStatus.EMPTY){
            emptyCoordinateList.add(west);
        }
        if(south.getStatus() == CoordinateStatus.EMPTY && this.centralstation.map.coordinateList[(int) Math.rint(south.getCoordinateX())][(int) Math.rint(south.getCoordinateY())] == CoordinateStatus.EMPTY){
            emptyCoordinateList.add(south);
        }
        if(east.getStatus() == CoordinateStatus.EMPTY && this.centralstation.map.coordinateList[(int) Math.rint(east.getCoordinateX())][(int) Math.rint(east.getCoordinateY())] == CoordinateStatus.EMPTY){
            emptyCoordinateList.add(east);
        }
		
		//if there is empty coordinate among for 4 coordinates = if the emptyCoordinateList is not empty
		if (!emptyCoordinateList.isEmpty()){
			Coordinate nextDestination = emptyCoordinateList.get(new Random().nextInt(emptyCoordinateList.size()));
			return nextDestination;
		}
		else{//If there is no EMPTY coordinates around robot it means
			//it is stuck so in order to got it out of that region
			//it should be able to visited VISITED coordinates so in the else statement
			//that case is implemented
			List<Coordinate> visitedCoordinateList = new ArrayList<Coordinate>();
			if(north.getStatus() == CoordinateStatus.EMPTY && this.centralstation.map.coordinateList[(int) Math.rint(north.getCoordinateX())][(int) Math.rint(north.getCoordinateY())] == CoordinateStatus.VISITED){
				visitedCoordinateList.add(north);
	        }
	        if(west.getStatus() == CoordinateStatus.EMPTY && this.centralstation.map.coordinateList[(int) Math.rint(west.getCoordinateX())][(int) Math.rint(west.getCoordinateY())] == CoordinateStatus.VISITED){
	        	visitedCoordinateList.add(west);
	        }
	        if(south.getStatus() == CoordinateStatus.EMPTY && this.centralstation.map.coordinateList[(int) Math.rint(south.getCoordinateX())][(int) Math.rint(south.getCoordinateY())] == CoordinateStatus.VISITED){
	        	visitedCoordinateList.add(south);
	        }
	        if(east.getStatus() == CoordinateStatus.EMPTY && this.centralstation.map.coordinateList[(int) Math.rint(east.getCoordinateX())][(int) Math.rint(east.getCoordinateY())] == CoordinateStatus.VISITED){
	        	visitedCoordinateList.add(east);
	        }
			Coordinate nextDestination = visitedCoordinateList.get(new Random().nextInt(visitedCoordinateList.size()));
			return nextDestination;
		}
	}
	
	/**
	 * 
	 * @return 
	 */
	
	//The algorithm that robot performs is implemented inside this function since it been
	//called by Simbad simulator repeatedly!
	protected void performBehavior() {
		//this if statement is used in order to keep the robots going unless running was set as false by the central station
		//because either the mission is over or the mission was stopped prematurely by the operator.
		if (running)
		{
			try{
				//these 2 if statements are used in order to follow a different behavior depending on the
				//robots' status, if the robot is BUSY when manually controlled, it wont follow the algorithm until control is relinquished.
				
				//this behavior executes while a robot is moving to a new coordinate to check when to stop.
				if(this.currentStatus == RobotStatus.RUNNING){
					 runningBehavior();
				}
				//this behavior analyzes the four directions and chooses an appropriate new coordinate to move to.
				else if(this.currentStatus == RobotStatus.AVAILABLE){
					availableBehavior();
				}
			}
			catch(Exception a){
				System.out.println("EXCEPTION performBehavior");
			}
		}
	}


	/**
	 * 
	 * @param position 
	 * @param name 
	 * @param id 
	 */
	//Constructor
	public Robot(Vector3d position, String name, int id) {
		super(position, name);
		currentStatus=RobotStatus.AVAILABLE;
		//When robots are created they all face same way. This can be changed by changing source code 
		robotDirection=Direction.EAST;
		currentCoordinates = new Coordinate(position,CoordinateStatus.VISITED);
		AdapterInterface = new Adapter();
		this.centralstation = CentralStation.getInstance();
        sonars = RobotFactory.addSonarBeltSensor(this, 4);
        camera = RobotFactory.addCameraSensor(this);
        this.counter = 0;
        this.robotID = id;
	}
	
	/**
	 * 
	 * @param command 
	 * @return 
	 */
	//In this function ever command from AvailableCommands are implemented as
	//required so that when operator(or central station) sends command object
	//they will be executed immedeately.
	//returns true if the command is performed successfully
	public void performCommand(Command command) {
		
		if(command.getCommand() == AvailableCommands.START_CONTROL){
			operatorControls = true;	
		}
		else if(command.getCommand() == AvailableCommands.STOP_CONTROL){
			operatorControls = false;
	    	setTranslationalVelocity(0);
			Point3d temp = new Point3d();
	    	this.getCoords(temp);
	    	this.currentCoordinates.changeCoordinate(new Vector3d(temp.x,0,temp.z));
			this.moveToPosition(this.AdapterInterface.convertCoordinate(Math.floor(this.currentCoordinates.getCoordinateX()), Math.floor(nextDestination.getCoordinateY())));
			this.getCoords(temp);
			this.currentCoordinates.changeCoordinate(new Vector3d(temp.x,0,temp.z));
			
			this.robotDirection=Direction.EAST;
			this.setDirection(Direction.NORTH);
			
		}
		else if(command.getCommand() == AvailableCommands.GO_UP){
			this.setDirection(Direction.NORTH);
			this.setTranslationalVelocity(0.5);
		}
		else if(command.getCommand() == AvailableCommands.GO_RIGHT){
			this.setDirection(Direction.EAST);
			this.setTranslationalVelocity(0.5);
		}
		else if(command.getCommand() == AvailableCommands.GO_DOWN){
			this.setDirection(Direction.SOUTH);
			this.setTranslationalVelocity(0.5);
		}
		else if(command.getCommand() == AvailableCommands.GO_LEFT){
			this.setDirection(Direction.WEST);
			this.setTranslationalVelocity(0.5);
		}
		else if(command.getCommand() == AvailableCommands.STOP_MISSION)
		{
			stop();
		}
	}
	
	/**
	 *
	 * @param nextDestination 
	 * @return 
	 * @throws InterruptedException 
	 */
	//this is for performCommand override for GO_DESTINATION
	//returns true if the command is performed successfully
	public void performCommand(Coordinate nextDestination){
		//if the coordinate is to the robot's east
		if((this.currentCoordinates.getCoordinateX()+1) == nextDestination.getCoordinateX()){
			this.setDirection(Direction.EAST);
			this.currentStatus = RobotStatus.RUNNING;
			this.setTranslationalVelocity(0.5);
		}
		//if the coordinate is to the robot's west
		else if((this.currentCoordinates.getCoordinateX()-1) == nextDestination.getCoordinateX()){
			this.setDirection(Direction.WEST);
			this.currentStatus = RobotStatus.RUNNING;
			this.setTranslationalVelocity(0.5);
		}
		//if the coordinate is to the robot's south
		else if((this.currentCoordinates.getCoordinateY()+1) == nextDestination.getCoordinateY()){
			this.setDirection(Direction.SOUTH);
			this.currentStatus = RobotStatus.RUNNING;
			this.setTranslationalVelocity(0.5);
		}
		//if the coordinate is to the robot's north
		else if((this.currentCoordinates.getCoordinateY()-1) == nextDestination.getCoordinateY()){
			this.setDirection(Direction.NORTH);
			this.currentStatus = RobotStatus.RUNNING;
			this.setTranslationalVelocity(0.5);
		}
	}

	/**
	 * 
	 * @return 
	 */
	//Turn robot's direction 90% to its right( -Math.PI / 2 = -90 )
	public void rotateRight() {
        this.rotateY(-Math.PI / 2);
        try{
	        if(this.getDirection() == Direction.NORTH){
	        	this.robotDirection = Direction.EAST;
	        }
	        else if(this.getDirection() == Direction.WEST){
	        	this.robotDirection = Direction.NORTH;
	        }
	        else if(this.getDirection() == Direction.SOUTH){
	        	this.robotDirection = Direction.WEST;
	        }
	        else if(this.getDirection() == Direction.EAST){
	        	this.robotDirection = Direction.SOUTH;
	        }
        }
        catch(Exception a){
        	System.out.println("EXCEPTION !!! in rotateRight() ");
        }
    }
	/**
	 * 
	 * @return 
	 */
	//updates the command so that new command will be executed!
	//the robot status is changed to BUSY and then to AVAILABLE since
	//we dont want robots to perform algorithm we use this
	//method to check before starting algorithm is any command is being performed
	//at that moment and if that returns true then robot continue to perform
	//requested command!
	public void update(Command command) {
		this.currentStatus = RobotStatus.BUSY;
		performCommand(command);
		if(!operatorControls){
			this.currentStatus = RobotStatus.AVAILABLE;
		}
	}

	/**
	 * 
	 * @return 
	 */
	//It get Image from robot's camera and store it in BufferedImage and return it for
	//analyzeImage() function to determine if box is in picture
	public BufferedImage captureImage() {
        BufferedImage temp = this.camera.createCompatibleImage();
        camera.copyVisionImage(temp);
        return temp;
    }

	/**
	 * 
	 * @return 
	 * @param image 
	 */
	//This function will analyze BufferedImage and determine
	//if the colored box is in the picture.
	public boolean analyzeImage(BufferedImage image) {
		
		String color = null;
        int rgb = image.getRGB(0,0);
        float hsb[] = new float[3];

        Color.RGBtoHSB((rgb>>16)&0xff, (rgb>>8)&0xff, rgb&0xff, hsb);
        
        if (hsb[1] < 0.1 && hsb[2] > 0.9) 
        	color = "White";
        else if (hsb[2] < 0.1) 
        	color = "Black";
        else {
            float deg = hsb[0]*360;
            if (deg >=  0 && deg <  30 && hsb[1] >= 0.5) 
            	color = "Red";
            else if (deg >=  30 && deg <  90) 
            	color = "Yellow";
            else if (deg >=  90 && deg < 150) 
            	color = "Green";
            else if (deg >= 150 && deg < 210) 
            	color = "Cyan";
            else if (deg >= 210 && deg < 270) 
            	color = "Blue";
            else if (deg >= 270 && deg < 330) 
            	color = "Magenta";
            else if (deg >= 330) 
            	color = "Red";
        }
        if (color == this.centralstation.boxColor)
        {
    		System.out.println("this entered");
            return true;
        }
        return false;
 }
	
	private void stop() {
		this.currentStatus = RobotStatus.DISABLED;
		this.setTranslationalVelocity(0.0);
		this.setRotationalVelocity(0.0);
		running = false;
	}
	
	//Updates robots coordinate by using Simbad simulator function getCoords
	public void updateCoordinate(){
		Point3d temp = new Point3d();
    	this.getCoords(temp);
    	this.currentCoordinates.changeCoordinate(new Vector3d(temp.x,0,temp.z));
	}
	
	//this function teleports robot to the exact location of nextDestination
	//this is used because double values were making problems and we set error rate of 0.05
	//so when robots get that close to the point it just teleports to the coordinate
	//and stops for further instructions. Also robotDirection is set to EAST
	//because when moveToPosition() is used robot automaticly turns to east by default(in source code)
	public void fixCoordinate(Direction direction){
		this.setTranslationalVelocity(0); 
		this.moveToPosition(this.AdapterInterface.convertCoordinate(nextDestination.getCoordinateX(), nextDestination.getCoordinateY()));
		this.updateCoordinate();
		this.robotDirection=Direction.EAST;
		this.setDirection(direction);
	}
	
	//the behavior that the robot will follow while moving towards its next destination
	private void runningBehavior() {
		this.updateCoordinate();
    	double threshold = 0.05;
    	Direction direction = getDirection();
    	if ((this.getDirection() == Direction.NORTH || this.getDirection() == Direction.SOUTH) && (Math.abs(this.currentCoordinates.getCoordinateY() - nextDestination.getCoordinateY()) < threshold))
    	{
			this.fixCoordinate(direction);
			this.counter = 0;
			this.setStatus(RobotStatus.AVAILABLE);
    	}
    	else if((this.getDirection() == Direction.WEST || this.getDirection() == Direction.EAST) && (Math.abs(this.currentCoordinates.getCoordinateX() - nextDestination.getCoordinateX()) < threshold))
    	{
    		this.fixCoordinate(direction);
			this.counter = 0;
			this.setStatus(RobotStatus.AVAILABLE);
    	}
	}
	
	//the behavior that the robot will follow to decide on the next destination, report to the map, and analyze obstacles.
	private void availableBehavior()
	{
		///////////////////////ALGORITHM START//////////////////////////////
		//this coordinate will be used after robot moves to new location
		//to update last locations status to VISITED since it came from there!
		Coordinate visitedCoor = currentCoordinates;
		Coordinate northCoor = checkCoordinate(Direction.NORTH);
		Coordinate westCoor = checkCoordinate(Direction.WEST);
		Coordinate southCoor = checkCoordinate(Direction.SOUTH);
		Coordinate eastCoor = checkCoordinate(Direction.EAST);
	
		//checks if the box has already been analyzed and keeps calling isBoxFound() and uses the counter to 
		//keep track where to continue since performBehavior is called 20 times a second
		if (counter < 210 && ((northCoor.getStatus() == CoordinateStatus.OBSTACLE && this.centralstation.map.coordinateList[(int) northCoor.getCoordinateX()][(int) northCoor.getCoordinateY()] != CoordinateStatus.OBSTACLE) 
	            || (westCoor.getStatus() == CoordinateStatus.OBSTACLE && this.centralstation.map.coordinateList[(int) westCoor.getCoordinateX()][(int) westCoor.getCoordinateY()] != CoordinateStatus.OBSTACLE) 
	            || (eastCoor.getStatus() == CoordinateStatus.OBSTACLE && this.centralstation.map.coordinateList[(int) eastCoor.getCoordinateX()][(int) eastCoor.getCoordinateY()] != CoordinateStatus.OBSTACLE) 
	            || (southCoor.getStatus() == CoordinateStatus.OBSTACLE && this.centralstation.map.coordinateList[(int) southCoor.getCoordinateX()][(int) southCoor.getCoordinateY()] != CoordinateStatus.OBSTACLE)))
	    {
			this.checkBoxes(northCoor, westCoor, southCoor, eastCoor);
		}
		
		//Capturing images is done, so the robot continues the algorithm.
		else
		{
			//here the 4 coordinates and their statuses are registered in the map
			this.reportToCS(northCoor, westCoor, southCoor, eastCoor);
			//here the calculation should be done for next coordinate to be visited(select EMPTY one if there is or select VISITED one)
			nextDestination = getDestination(northCoor, westCoor, southCoor, eastCoor);
			
			//after calculation performCommand() will be called with the overridden one!!
			performCommand(nextDestination);
			this.centralstation.reportTheVisited(visitedCoor);

			///////////////////////ALGORITHM END//////////////////////////////
		}
	}
	
	public void checkBoxes(Coordinate northCoor, Coordinate westCoor, Coordinate southCoor, Coordinate eastCoor) {
		/*we keep track of each simulation step in a separate counter in order to reset it after every time we enter
		  the CAPTUREIMAGE status from performBehavior() because we cant manipulate the counter from the superclass
		  this allows us to control how long a robot waits for the camera to update its view so we can analyze the pictures*/
		counter++;

		//changes direction to the obstacle if found
		if (eastCoor.getStatus() == CoordinateStatus.OBSTACLE && counter == 10)
		{
			this.setDirection(Direction.EAST);
		}
		//wait 30 simulation steps in order for the camera to update to capture the image properly
		if (eastCoor.getStatus() == CoordinateStatus.OBSTACLE && counter == 40)
		{
			BufferedImage temp = this.captureImage();
			if (analyzeImage(temp))
			{
				Image temp2 = new Image();
				temp2.image = temp;
				temp2.coordinate = eastCoor;
				this.centralstation.obstacleList.add(temp2);
			}
		}
		
		//waits 20 simulation steps to capture the previous image then changes direction if obstacle is found
		else if (westCoor.getStatus() == CoordinateStatus.OBSTACLE && counter == 60)
		{
			this.setDirection(Direction.WEST);
		}
		//wait 30 simulation steps in order for the camera to update to capture the image properly
		if (westCoor.getStatus() == CoordinateStatus.OBSTACLE && counter == 90)
		{
			BufferedImage temp = this.captureImage();
			if (analyzeImage(temp))
			{
				Image temp2 = new Image();
				temp2.image = temp;
				temp2.coordinate = westCoor;
				this.centralstation.obstacleList.add(temp2);
			}
		}
		
		//waits 20 simulation steps to capture the previous image then changes direction if obstacle is found
		else if (southCoor.getStatus() == CoordinateStatus.OBSTACLE && counter == 110)
		{
			this.setDirection(Direction.SOUTH);
		}
		//wait 30 simulation steps in order for the camera to update to capture the image properly
		if (southCoor.getStatus() == CoordinateStatus.OBSTACLE && counter == 140)
		{
			BufferedImage temp = this.captureImage();
			if (analyzeImage(temp))
			{
				Image temp2 = new Image();
				temp2.image = temp;
				temp2.coordinate = southCoor;
				this.centralstation.obstacleList.add(temp2);
			}

		}
		
		//waits 20 simulation steps to capture the previous image then changes direction if obstacle is found
		else if (northCoor.getStatus() == CoordinateStatus.OBSTACLE && counter == 160)
		{
			this.setDirection(Direction.NORTH);
		}
		//wait 30 simulation steps in order for the camera to update to capture the image properly
		if (northCoor.getStatus() == CoordinateStatus.OBSTACLE && counter == 190)
		{
			BufferedImage temp = this.captureImage();
			if (analyzeImage(temp))
			{
				Image temp2 = new Image();
				temp2.image = temp;
				temp2.coordinate = northCoor;
				this.centralstation.obstacleList.add(temp2);
			}
		}
	}
	
};

